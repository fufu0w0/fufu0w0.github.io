<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="概述dijkstra算法是典型的单源点最短路的算法，可以求取图中各点到初始点的最短路，适用于边的权值非负的图（有向或无向）。">
<meta name="keywords" content="图论,最短路">
<meta property="og:type" content="article">
<meta property="og:title" content="Dijkstra单源点最短路径算法详解">
<meta property="og:url" content="http://yoursite.com/2019/10/11/dijkstra-algrithom/index.html">
<meta property="og:site_name" content="yunxin&#39;s blog">
<meta property="og:description" content="概述dijkstra算法是典型的单源点最短路的算法，可以求取图中各点到初始点的最短路，适用于边的权值非负的图（有向或无向）。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-04-03T13:57:32.438Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dijkstra单源点最短路径算法详解">
<meta name="twitter:description" content="概述dijkstra算法是典型的单源点最短路的算法，可以求取图中各点到初始点的最短路，适用于边的权值非负的图（有向或无向）。">

<link rel="canonical" href="http://yoursite.com/2019/10/11/dijkstra-algrithom/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dijkstra单源点最短路径算法详解 | yunxin's blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yunxin's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">simply record what I have learned</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/11/dijkstra-algrithom/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="fufu0w0">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yunxin's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dijkstra单源点最短路径算法详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 22:34:20" itemprop="dateCreated datePublished" datetime="2019-10-11T22:34:20+08:00">2019-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-03 21:57:32" itemprop="dateModified" datetime="2020-04-03T21:57:32+08:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>dijkstra算法是典型的单源点最短路的算法，可以求取图中各点到初始点的最短路，适用于边的权值非负的图（有向或无向）。</p><a id="more"></a>
<p>将图的点集分为两个集合，从源点到该点的最短路径已确定的点的集合$S$，和未确定到源点最短路径的点的集合R。从集合R中选取只经过在集合S中的点到源点距离最短的点加入集合S，并更新此时在集合R中的点到源点的最小距离，更新规则为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dis[v] =  (dis[v] &gt; dis[u] + g.map[u][v]) ? (dis[u] + g.map[u][v]) : dis[v];</span><br></pre></td></tr></table></figure>
<p>在集合S加入新的点以后，比较在集合R中的点经过这个点到源点的距离和不经过这个点到源点的距离，选取较小者作为此时该点距离源点的距离，这个过程叫松弛（relaxtion)操作。</p>
<p>tips : 将最短距离减小的过程被叫做’relaxation’是因为各点到源点最短路相当于是被“拉伸”的，因此更新最短路的操作就是在使最短路径“松弛”。</p>
<p>The notion of “relaxation” comes from an analogy between the estimate of theshortest path and the length of a helical tension spring, which is notdesigned for compression. Initially, the cost of the shortest path is anoverestimate, likened to a stretched out spring. As shorter paths are found,the estimated cost is lowered, and the spring is relaxed. Eventually, theshortest path, if one exists, is found and the spring has been relaxed to itsresting length</p>
<p>重复从集合$R$取点，加入集合$S$的过程，直到所有的点都加入到了集合$S$中，此时就求得了源点到其余各点的最小距离，算法结束。</p>
<p>综上，dijkstra算法实际就是包含了两个对集合的操作操作：</p>
<p>1.包括从$R$中取出到源点最小的点加入到集合$S$中;</p>
<p>2.更新$R$中剩下的点到源点可能的最短距离。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h3><p>遍历是Dijkstra算法最朴素的实现方式，过程描述如下：</p>
<p>遍历所有点，从中找出未加入集合S且距离源点最短的点加入集合S中。</p>
<p>遍历所有点，从中找出未加入集合S的点更新其到远点的最短距离。</p>
<p>重复1和2，循环直到所有可达的点都加入到集合S.</p>
<p>时间复杂度是$O(n^2)$，$n$为图上点的个数。</p>
<p>c++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mygragh</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//邻接矩阵存储</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(mygragh g,<span class="keyword">int</span> dis[],<span class="keyword">int</span> pre[],<span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g.n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g.<span class="built_in">map</span>[v0][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            dis[i] = g.<span class="built_in">map</span>[v0][i];</span><br><span class="line">            pre[i] = v0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dis[i] = INT_MAX;</span><br><span class="line">            pre[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[v0] = <span class="number">0</span>;</span><br><span class="line">    pre[v0] = v0;</span><br><span class="line">    visit[v0]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[j]==<span class="literal">false</span>&amp;&amp;dis[j]&lt;min)&#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[u] = <span class="literal">true</span>;<span class="comment">//如果要找某个点到源点的最短距离，我们可以在选取的最短距离的点是目标点时跳出循环。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[j]==<span class="literal">false</span>&amp;&amp;dis[j]&gt;dis[u]+g.<span class="built_in">map</span>[u][j]&amp;&amp;g.<span class="built_in">map</span>[u][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                dis[j] = dis[u] + g.<span class="built_in">map</span>[u][j];</span><br><span class="line">                pre[j] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小顶堆实现"><a href="#小顶堆实现" class="headerlink" title="小顶堆实现"></a>小顶堆实现</h3><p>通过邻接矩阵和堆来实现dijkstra最短路径算法。过程描述如下：</p>
<p>初始化，建堆，节点的权值（是当前从源点到该节点最短的距离）初始化为INT_MAX。</p>
<p>取顶，取堆顶元素（当前不在最短路径树中距离源点距离最小的节点）加入最短路径树，交换堆顶和堆底，堆化（从当前节点开始下滤）恢复堆序性。</p>
<p>松弛操作，将点v加入最短路径树以后，更新所有和v相邻的点到源点的距离,通过decresekey，根据pos数组找到点在堆中对应的位置，减小权值，并进行上滤操作。（权值只会减小)改变堆中某点的w之后调整他在堆中的位置（因为w只会减小，v点以下堆序性不会被破坏，因此只需要执行上滤操作即可恢复整体堆序性).</p>
<p>重复2,3，直到堆中元素全部取出。</p>
<p>时间复杂度为$O(e*logv)$，$e$是图上边的条数，$v$是图上点的个数。在这里用的是二叉堆实现，如果用Fibonacci堆，时间耗费还可以更低。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">预备知识：堆</span><br><span class="line">1.建堆，从第一个有孩子的节点开始进行下滤，直到根节点</span><br><span class="line">2.取顶，交换，下滤(在有的教材中也叫堆化)</span><br><span class="line">3.插入，在堆底插入，从它开始上滤。</span><br><span class="line">4.上滤：该节点以上的堆除该节点以外皆有序，以该节点为根子树均有序，上滤一次即可恢复堆序性。</span><br><span class="line">5.下滤：该节点的左右子树均有序，下滤一次，以该节点为根的子树恢复堆序性。</span><br></pre></td></tr></table></figure>
<p>c++实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">adListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    adListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">adList</span>&#123;</span></span><br><span class="line">    adListNode *head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mygragh</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//点的个数</span></span><br><span class="line">    adList *<span class="built_in">array</span>;<span class="comment">//存储边的邻接表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct adListNode* <span class="title">createAdListNode</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adListNode</span> *<span class="title">node</span> = (<span class="title">struct</span> <span class="title">adListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">adListNode</span>));</span></span><br><span class="line">    node-&gt;id = v;</span><br><span class="line">    node-&gt;weight = weight;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct mygragh* <span class="title">creatMyGraph</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mygragh</span> *<span class="title">graph</span> = (<span class="title">struct</span> <span class="title">mygragh</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">mygragh</span>));</span></span><br><span class="line">    graph-&gt;<span class="built_in">array</span> = (struct adList *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(struct adList));</span><br><span class="line">    <span class="comment">//array是元素类型为adList的数组，有几个点就有几个adList所以它分配空间大小是n*sizeof(struct adList);</span></span><br><span class="line">    graph-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        graph-&gt;<span class="built_in">array</span>[i].head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(mygragh *g,<span class="keyword">int</span> s,<span class="keyword">int</span> d,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    adListNode *node = createAdListNode(d, w);</span><br><span class="line">    node-&gt;next = g-&gt;<span class="built_in">array</span>[s].head;</span><br><span class="line">    g-&gt;<span class="built_in">array</span>[s].head = node;</span><br><span class="line">    <span class="comment">//无向图</span></span><br><span class="line">    node = createAdListNode(s, w);</span><br><span class="line">    node-&gt;next = g-&gt;<span class="built_in">array</span>[d].head;</span><br><span class="line">    g-&gt;<span class="built_in">array</span>[d].head = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heapNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miniHeap</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> capasity;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> *pos;<span class="comment">//存储图的点在堆中的位置</span></span><br><span class="line">    heapNode **<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct heapNode* <span class="title">createheapNode</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    heapNode *node = (struct heapNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct heapNode));</span><br><span class="line">    node-&gt;id = id;</span><br><span class="line">    node-&gt;w = weight;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct miniHeap* <span class="title">createMiniHeap</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">miniHeap</span> *<span class="title">heap</span> = (<span class="title">struct</span> <span class="title">miniHeap</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">miniHeap</span>));</span></span><br><span class="line">    heap-&gt;pos = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    heap-&gt;capasity = n;</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span> = (struct heapNode **)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(struct heapNode *));</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(heapNode **a,heapNode **b)</span></span>&#123;</span><br><span class="line">    heapNode *t;</span><br><span class="line">    t = *b; <span class="comment">//因为he.array数组中的元素是指向heapNode的指针，要在函数中实现元素的交换，要要传入指针的地址。和swap(int *a,int *b)是一样的，不然传入函数以后是在内存堆栈上重新开辟了一个空间，然后把这两个指针复制到那个空间中，交换也只在这个函数的空间中进行，而实际想要交换的两个指向堆中节点的指针没有交换。</span></span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(struct miniHeap* h,<span class="keyword">int</span> inx)</span></span>&#123;</span><br><span class="line">    <span class="comment">//下滤</span></span><br><span class="line">    <span class="keyword">int</span> left, right, mini;</span><br><span class="line">    mini = inx;</span><br><span class="line">    left = inx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    right = inx * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;h-&gt;size&amp;&amp;((h-&gt;<span class="built_in">array</span>[left]-&gt;w)&lt;(h-&gt;<span class="built_in">array</span>[mini]-&gt;w)))&#123;</span><br><span class="line">        mini = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;h-&gt;size&amp;&amp;((h-&gt;<span class="built_in">array</span>[right]-&gt;w)&lt;(h-&gt;<span class="built_in">array</span>[mini]-&gt;w)))&#123;</span><br><span class="line">        mini = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inx!=mini)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">heapNode</span> *<span class="title">p</span> = <span class="title">h</span>-&gt;<span class="title">array</span>[<span class="title">inx</span>];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">heapNode</span> *<span class="title">minist</span> = <span class="title">h</span>-&gt;<span class="title">array</span>[<span class="title">mini</span>];</span></span><br><span class="line">        h-&gt;pos[p-&gt;id] = mini;</span><br><span class="line">        h-&gt;pos[minist-&gt;id] = inx;</span><br><span class="line">        swap(&amp;h-&gt;<span class="built_in">array</span>[inx], &amp;h-&gt;<span class="built_in">array</span>[mini]);<span class="comment">//交换堆中的节点。节点向下一层</span></span><br><span class="line">        heapify(h, mini);<span class="comment">//递归的调用heapify,每次向下一层直到该节点到达它在堆中应该的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function">struct heapNode* <span class="title">getTop</span><span class="params">(miniHeap *h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h-&gt;size==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heapNode</span> *<span class="title">node</span> = <span class="title">h</span>-&gt;<span class="title">array</span>[0];</span></span><br><span class="line">    h-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = h-&gt;<span class="built_in">array</span>[h-&gt;size - <span class="number">1</span>];</span><br><span class="line">    h-&gt;pos[h-&gt;<span class="built_in">array</span>[<span class="number">0</span>]-&gt;id] = <span class="number">0</span>;</span><br><span class="line">    h-&gt;pos[node-&gt;id] = h-&gt;size - <span class="number">1</span>;<span class="comment">//把该点对应在堆中的坐标放到堆末位，再把size--，就相当于这个节点已经不在堆中</span></span><br><span class="line">    h-&gt;size--;</span><br><span class="line">    heapify(h, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decreasekey</span><span class="params">(miniHeap *h,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上滤</span></span><br><span class="line">    <span class="keyword">if</span>((h-&gt;pos[v])&lt;(h-&gt;size))&#123;<span class="comment">//判断该节点是否还在堆里。</span></span><br><span class="line">        h-&gt;<span class="built_in">array</span>[h-&gt;pos[v]]-&gt;w = w;</span><br><span class="line">        <span class="keyword">int</span> a = h-&gt;pos[v];</span><br><span class="line">        <span class="keyword">int</span> p = (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h-&gt;<span class="built_in">array</span>[a]-&gt;w&gt;h-&gt;<span class="built_in">array</span>[p]-&gt;w)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            h-&gt;pos[h-&gt;<span class="built_in">array</span>[a]-&gt;id] = p;</span><br><span class="line">            h-&gt;pos[h-&gt;<span class="built_in">array</span>[p]-&gt;id] = a;</span><br><span class="line">            swap(&amp;h-&gt;<span class="built_in">array</span>[a], &amp;h-&gt;<span class="built_in">array</span>[p]);</span><br><span class="line">            a = p;</span><br><span class="line">            p = (a - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inHeap</span><span class="params">(miniHeap *h,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h-&gt;pos[v]&lt;h-&gt;size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(mygragh *g, <span class="keyword">int</span> *dis, <span class="keyword">int</span> *pre, <span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g-&gt;n;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; n &lt;&lt; "\n";</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">miniHeap</span> *<span class="title">h</span> = <span class="title">createMiniHeap</span>(<span class="title">n</span>);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        dis[i] = INT_MAX;</span><br><span class="line">        h-&gt;pos[i] = i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">heapNode</span> *<span class="title">node</span> = <span class="title">createheapNode</span>(<span class="title">i</span>, <span class="title">INT_MAX</span>);</span><span class="comment">//初始化所有元素值相等，为INT_MAX,堆不用建，一开始就是好的。</span></span><br><span class="line">        h-&gt;<span class="built_in">array</span>[i] = node;</span><br><span class="line">        pre[i] = v0;</span><br><span class="line">        h-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[v0] = <span class="number">0</span>;</span><br><span class="line">    pre[v0] = v0;</span><br><span class="line">    decreasekey(h, v0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(h-&gt;size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">heapNode</span> *<span class="title">node</span> = <span class="title">getTop</span>(<span class="title">h</span>);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">adListNode</span> *<span class="title">a</span> = <span class="title">g</span>-&gt;<span class="title">array</span>[<span class="title">node</span>-&gt;<span class="title">id</span>].<span class="title">head</span>;</span></span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"route : " &lt;&lt; node-&gt;id &lt;&lt; " " &lt;&lt; a-&gt;id &lt;&lt; "\n";</span></span><br><span class="line">            <span class="keyword">if</span>((dis[node-&gt;id]+a-&gt;weight)&lt;(dis[a-&gt;id])&amp;&amp;inHeap(h,a-&gt;id))&#123;</span><br><span class="line">                dis[a-&gt;id] = dis[node-&gt;id] + a-&gt;weight;</span><br><span class="line">                decreasekey(h, a-&gt;id, dis[a-&gt;id]);</span><br><span class="line">                pre[a-&gt;id] = node-&gt;id;</span><br><span class="line">            &#125;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现细节</p>
<p>堆中维护一个pos数组保存节点到节点在堆中所在位置，在松弛操作中需要知道这个位置以更新他们的权值。每次交换堆中的节点后，pos数组中保存点的位置也要交换。</p>
<p>在函数中交换指向节点的指针（被交换的对象是地址），函数调用时要交换两个指针，函数的参数应该是指针的地址，上面*p=h-&gt;array[inx],是把这个指针复制了一分给p，而p和h-&gt;array[inx]的值相同，都是指向i指向堆中的节点的值针，即在他们的值是节点的地址。但是他们不是同一个，他们有不同的地址，如果交换swap(&amp;p,&amp;mini),是p和mini这两个变量中存放的地址发生交换，而不会交换h-&gt;array[inx]和h-&gt;array[mini]中存放的地址，而数组中存放的地址，才是我们实际需要交换的，所以不可以用swap(&amp;p,&amp;mini).换句话说，这两个指针有相同的值，但是他们的地址是不一样的。</p>
<h2 id="优先级队列实现"><a href="#优先级队列实现" class="headerlink" title="优先级队列实现"></a>优先级队列实现</h2><p>第三种实现方式是通过使用STL库中的优先级队列实现。priority_queue不支持降低节点权值的操作，要解决此问题，我们通过插入与该节点同名但值更小的另一个节点来实现decreasekey()操作。</p>
<p>在优先队列中有多个相同节点，它们有不同的权值。每当一个节点的到源点的最短路径减小时，就在priority_queue中添加一个同名但值更小的节点。即使存在多个同名节点，我们也只考虑到源点的距离最小最小的节点，而忽略其他节点。</p>
<p>时间复杂度是$O(ELogV)$</p>
<p>c++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queueNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (queueNode a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w==a.w)&#123;</span><br><span class="line">            <span class="keyword">return</span> v &gt; a.v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w &gt; a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct queueNode <span class="title">createQueueNode</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queueNode</span> <span class="title">qnode</span>;</span></span><br><span class="line">    qnode.v = v;</span><br><span class="line">    qnode.w = w;</span><br><span class="line">    <span class="keyword">return</span> qnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(mygragh *g, <span class="keyword">int</span> *dis, <span class="keyword">int</span> *pre, <span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g-&gt;n;</span><br><span class="line">    <span class="keyword">int</span> size = n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; size &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    priority_queue&lt;queueNode&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        dis[i]=INT_MAX;</span><br><span class="line">        pre[i] = v0;</span><br><span class="line">        queueNode pno;</span><br><span class="line">        pno=createQueueNode(i, INT_MAX);</span><br><span class="line">        pq.push(pno);</span><br><span class="line">    &#125;</span><br><span class="line">    dis[v0] = <span class="number">0</span>;</span><br><span class="line">    queueNode pno = createQueueNode(v0, <span class="number">0</span>);</span><br><span class="line">    pq.push(pno);</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">        pno = pq.top();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"getto :  "</span> &lt;&lt; <span class="string">"   "</span> &lt;&lt; pno.v &lt;&lt; <span class="string">"  "</span> &lt;&lt; pno.w &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">        adListNode *adnode = g-&gt;<span class="built_in">array</span>[pno.v].head;</span><br><span class="line">        <span class="keyword">while</span>(adnode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(adnode-&gt;weight+dis[pno.v]&lt;dis[adnode-&gt;id])&#123;</span><br><span class="line">                dis[adnode-&gt;id] = adnode-&gt;weight+dis[pno.v];</span><br><span class="line">                queueNode minode = createQueueNode(adnode-&gt;id, adnode-&gt;weight+dis[pno.v]);</span><br><span class="line">                pq.push(minode);<span class="comment">//relax,因为不能改变优先级队列中已有的节点的权值，因此插入一个同名权值更小的节点到优先级队列里啦</span></span><br><span class="line">                pre[adnode-&gt;id] = pno.v;</span><br><span class="line">            &#125;</span><br><span class="line">            adnode = adnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图用邻接矩阵存储，和堆实现中的代码一样。</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dijkstra算法是Dijkstra在咖啡馆休息时想出的，他没有想到这个 20 分钟的发明会成为他最著名的成就之一，以他的名字命名，还因此获得了计算机科学领域的最高奖项图灵奖。作为计算单源点最短路的算法广泛应用在很多领域（当然我知道的比赛题目之外的应用只有路由算法）。之前数模校赛地时候就用上了Dijkstra算法，上学期学算法的时候觉得最简单的就是贪心算法，但自己实现了一遍才发现之前有很多没有学懂的地方。</p>
<p>说点题外话作为这篇博客的结尾吧，到现在我也记不住Dijkstra的拼写，每次打他的名字都是打完’Dijie’发现想不起来后面的字母是什么才老老实实翻到前面ctrl c，因为Dijkstra是荷兰人，名字不符合英语发音规则。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.geeksforgeeks.org/dijkstras-algorithm-for-adjacency-list-representation-greedy-algo-8/" target="_blank" rel="noopener">Dijkstra’s Algorithm for Adjacency List Representation</a></p>
<p><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/" target="_blank" rel="noopener">Dijkstra’s Shortest Path Algorithm using priority_queue of STL</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/图论/" rel="tag"># 图论</a>
              <a href="/tags/最短路/" rel="tag"># 最短路</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2020/01/08/PAT-1030-sollution/" rel="prev" title="PAT 1030 Travel Plan (30分) dfs+回溯">
                  PAT 1030 Travel Plan (30分) dfs+回溯 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历实现"><span class="nav-number">2.1.</span> <span class="nav-text">遍历实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小顶堆实现"><span class="nav-number">2.2.</span> <span class="nav-text">小顶堆实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优先级队列实现"><span class="nav-number">3.</span> <span class="nav-text">优先级队列实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="fufu0w0"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">fufu0w0</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fufu0w0</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  


















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

  

</body>
</html>
